{"name":"Mathematically structured computer programs","tagline":"slides: intro to category theory, haskell, monads, state","body":"\r\n## Mathematically structured computer programs\r\n\r\nSlides for a talk to undergraduates given on 2011-02-28 introducting the idea of structuring a program with mathematics. The goal was to motivate and understand the category theory behind this small Haskell program\r\n\r\n```haskell\r\nimport System.Environment\r\n\r\nliftM           :: (Monad m) => (a -> b) -> m a -> m b\r\nliftM f t       = t >>= (\\y -> return (f y))\r\n\r\nq               :: (Ord a) => [a]->[a]\r\nq []            = []\r\nq (x:xs)        = q [y|y<-xs,y<x] ++ [x] ++ q [y|y<-xs,y>=x]\r\n\r\nmain = (liftM q) getArgs >>= print\r\n```\r\n\r\nThe slides give a brief introduction to category theory, monads, the list and state monads, and then in a handwavy way introduce the IO monad as a sort of state monad.\r\n\r\nIn the slides I wrote \"Imagine trying to prove a theorem of mathematics which involves functions which are not well defined!\" This is overly simplistic and conflates imperative with side-effecting. There is a big difference between imperative and impure. For instance one can go to any treatment of algorithms such as [Cormen et al](http://mitpress.mit.edu/books/introduction-algorithms) or [Kleinberg and Tardos](http://www.amazon.com/Algorithm-Design-Jon-Kleinberg/dp/0321295358) and find many mathematical theorems proved about what are for the most part pure functions written in an imperative style, notably making heavy use of destructive in place update.\r\n\r\nSome of the students liked the idea that category theoretic ideas could be used to program a computer, and some just thought it was weird.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}